Some tasks feel like an adventure from the very beginning. The first mission was one of them. Designing a WordPress plugin from scratch, with no shortcuts, no sketchy dependencies, while respecting a clean, professional architecture. It was exciting, almost intoxicating. I knew exactly what I wanted: a plugin that detects "above the fold" visible links when a page loads, sends them efficiently via AJAX or REST, with lightweight yet precise tracking, all wrapped in a modern, modular, testable, and robust structure.

So I broke the work into pieces, carefully. Created the database with an index on the `created_at` column for performance, injected the scripts conditionally to avoid unnecessary frontend bloat, secured everything with nonces, verified user roles... every detail was part of the puzzle. Even the frontend deactivation for logged-in admins , why pollute the statistics with my own tests? The idea was simple, but executing it demanded rigor and a bit of cunning.

Once the core of the plugin was ready, the second phase came: unit testing. That's where the story took a different turn. What I thought would be a formality , writing clean tests, mocking WordPress functions with Brain Monkey, running assertions , quickly turned into a battlefield. From the very first lines of PHPUnit, a strange error appeared in the logs: `Patchwork\Exceptions\DefinedTooEarly`. I assumed it was a mistake, maybe a bad autoload setup. But no. Again, and again, and again. Always the same invisible wall.

So I dug deeper. Compared versions. Traced the root cause. Reorganized files. Tried reversing the calls. Tested without Composer, with Composer, outside WordPress, inside WordPress, using Docker, without Docker. I even uninstalled and reinstalled Brain Monkey to check if it was a version-related bug. Still nothing. The trap kept closing in. Patchwork , the function redefinition engine Brain Monkey relies on , simply doesn’t support early inclusion of certain WordPress functions. And since `__()` or `add_action()` are often invoked right at plugin load time, the tests fail... before they even begin.

At that point, there were two options. Give up, or rethink. I chose the second. Because even if unit testing proved impossible in that setup, my desire for reliability remained. I switched to another philosophy: integration testing. Using WP-CLI to automate scenarios, activating the plugin in a clean WordPress environment, injecting fake links, simulating a visitor, tracking requests, inspecting the database. It was slower, more demanding... but it worked. And most importantly, it was real.

What I learned along the way is that software engineering is not always a straight line. There are dead ends, traps, poorly documented tools, or hidden incompatibilities. But there’s also a kind of energy you find when you truly believe in the quality of what you're building. I saw those obstacles not as failures, but as eye-openers. They forced me to make intentional choices, to understand the boundaries of WordPress more clearly, and to refocus on the essentials: making sure the plugin truly works, on a real site, for real users.

So yes, I couldn’t write the unit tests as initially planned. But I gained a deeper understanding of the system, a solid integration methodology, and above all, the satisfaction of having seen it through. Because every line of code I wrote, every bug I tracked, every workaround I devised... was driven by passion. And that, no test can ever measure.
